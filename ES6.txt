ES6

let 声明变量，在代码块内部有效
	只要代码块中存在let，整个代码块中的变量都不受外界影响
	同一个变量可以用var同时声明 ：var a =10; var a = 20;
	但有let则变量不能重复声明
	
为什么要块级作用域
	1.第一种场景，内层变量可能会覆盖外层变量。
		//var会付给变量地址，这里会赋两个新地址，但是第二个地址没有指向值，所以为undefined	
		var time = new Date();

		function fun() {
			console.log(time);
			if (false) {
				var time = "Hello World!";
			};
		};

		fun();	//undefined
		
	2.第二种场景，用来计数的循环变量泄露为全局变量。
		var string = "Hello World!";

		for (var i = 0; i < string.length; i++) {
			console.log(string[i]);
		};

		console.log("循环结束");
		console.log(i);	//12
		
立即执行函数
	javascript:
		(function () {
			var temp=
		}());
	ES6:
		{
			let temp=
		}
		
	例：
		<script type="text/javascript">//<script type="text/traceur">
		console.log("ES5:");
		function fun() {
			console.log("I am outside!");
		};

		(function () {
			if (false) {
				function fun() {//立即执行函数会将该函数提出覆盖上面函数
					console.log("I am inside!");
				};
			};

			fun();//ES5(JS):I am inside!  ES6:I am outside!
		}());
		</script>
		
const声明的常量只在当前代码块有效,与let相似，同样也有暂时性死区，也不可重复声明
	const声明对象
		const person = {};
		person.name  = "Zhangsan";
		person.age   = 30;

		console.log(person.name);	//Zhangsan
		console.log(person.age);	//30
		console.log(person);		//Object {name: "Zhangsan", age: 30}
		person={};//报错  read-only
	对象冻结：
		const person = Object.freeze({});
		person.age = 30;
		console.log(person.age);//undefined
		要使用这种方法定义：
			const person = Object.freeze({
				name:"zhangsan",
				age:20
			});
			
	彻底冻结函数
	//彻底冻结
		var constantize = (obj) =>{
			Object.freeze(obj);
			Object.keys(obj).forEach((key,value)=>{
				if (typeof obj[key]==='object') {
					constantize(obj[key]);
				}
			});
		};

跨模块常量
	//module.js
	export const variantName = "variantValue";
	export const intVariantName = "variantValue";
	//use.js
	import * as variant from './module';
	import {variantName,intVariantName} as variant from './module';
	console.log(variant.variantName)
	
全局变量属性
ES6规定，var命令和function命令声明的全局变量，属于全局对象的属性；let命令、const命令、class命令声明的全局变量，不属于全局对象的属性。
	var varName = "varValue";
	//浏览器环境
	console.log(window.varName);
	//Node.js环境下
	console.log(global.varName);
	//通用环境
	console.log(this.varName);

	let letName = "letValue";
	console.log(window.letName);  //undefined --use strict
	console.log(this.letName);   //undefined --use strict
	
数组解构
	//ES5
	// var a =1;
	// var b =2;
	//ES6
	var [a,b,c]=[1,2,3];
	console.log(b);
	
	let[foo,[[bar],base]]=[1,[[2],3]];
	console.log(base);

	let[,,third]=["first","second","third"];
	console.log(third);

	let[head,...tail]=[0,1,2,3,4,5,6,7,8,9];
	console.log(head); //0
	console.log(tail); //[1, 2, 3, 4, 5, 6, 7, 8, 9]
	
不完全解构  不会报错 等号右边如果不是可遍历的结构就会报错  只要某种数据结构具有Iterator接口，都可以采用数组形式的解构赋值。
	let [x,y]=[1,2,3];
	console.log(x); //1
	console.log(y); //2

	let [a,[b],c]=[1,[2,3],4]
	console.log(a);//1
	console.log(b);//2
	console.log(c);//4
	
	//设置默认值
	var [temp="string"]=[];
	console.log(temp);//string
	var [temp="string"]=["tempString"];
	console.log(temp);//tempString
	var [x="aaa",y]=["bbb"];
	console.log(x);//bbb
	console.log(y);//undefined
	
	var [temp]=1;//报错
	
对象解构
	赋值（对象的属性没有次序，变量必须与属性同名，才能取到正确的值）：
		var{name,age}={name:"zhangsan",age:28};
		console.log(name);
		console.log(age);
		var{name:person_name,age:person_age}={name:"zhangsan",age:28};
		console.log(person_name);
		console.log(person_age);

		let object = {first:"hello",last:"world"};
		let {first:firstName,last:lastName}=object;
		console.log(firstName);
		console.log(lastName);
	现有对象方法           对象的解构赋值，可以很方便地将现有对象的方法，赋值到某个变量。
		console.log(Math.sin(Math.PI/6));
		let{sin,cos,tan}=Math;
		console.log(sin(Math.PI/6));
	字符串结构赋值
		const [a,b,c,d,e]="hello";
		const {length:len}="hello";
		console.log(len);//5
		const{lenght}="Hello world";
		console.log(len);//12

函数参数结构赋值
	function sum([x,y]){
		return x+y;
	};
	console.log(sum([1,2]));//3

	function fun({x=0,y=0}={}){
		return [x,y];
	}
	console.log(fun({x:100,y:200}));//[100, 200]
	console.log(fun({x:100}));//[100, 0]

	function fun1({a,b}={a:0,b:0}){
		return [a,b];
	}
	console.log(fun1({a:100,b:200}));//[100, 200]
	console.log(fun1({a:100}));//[100, undefined]
	console.log(fun1({}));//[undefined, undefined]
	console.log(fun1());//[0,0]
	
交换变量的值
	//ES6
	console.log("ES6:");
	var x = 100;
	var y = 200;
	console.log("交换前：");
	console.log("x = " + x);	//x = 100
	console.log("y = " + y);	//y = 200
	[x, y] = [y, x];
	console.log("交换后：");
	console.log("x = " + x);	//x = 200
	console.log("y = " + y);	//y = 100
	
函数返回多个值
	function fun(){
		return [1,2,3];
	}
	var [x,y,z]=fun();
	console.log(y);//2
	
函数返回对象
	function fun(){
		return {
			name:"zhangsan",
			age:28
		};
	}
	var {name,age}=fun();
	console.log(name);//zhangsan
	var{name:person_name,age:person_age}=fun();
	console.log(person_age);//28
	var person=fun();
	console.log(person.age);//28
	
函数参数的定义
		//参数是一组有次序的值
	function fun([x,y,z]){
		
	}
	fun([100,200,300]);
	//参数是一组无次序的值
	function fun({id,name,age}){

	}
	fun({id:"100",name:"zhangsan",age:28});
	
提取Json数据
	var jsonData={
		id:"001",
		name:"zhangsan",
		age:28,
		score:[98,148,107]
	};
	console.log(jsonData);
	console.log("ES5:");
	console.log("Person's name is:"+jsonData.name);
	console.log("ES6:");
	let {id:number,name,age,score:Chinese}=jsonData;
	console.log("Person's Chinese score is:"+Chinese);//Person's Chinese score is:98,148,107
	
遍历map
	var map = new Map();
	map.set("id","007");
	map.set("name","zhangsan");
	console.log(map);
	for(let [key,value] of map){
		console.log(key+" is "+value);
	}
	for(let [key] of map){
		console.log(key);
	}
	for(let [,value] of map){
		console.log(value);
	}
字符串模板：
	let drink = "juice";
	let food = "egg";
	let breakfast=`my breakfast is ${drink} and ${food}`;
	console.log(breakfast);//my breakfast is juice and egg
展开操作符：...
	var foods = ['apple','milk'];
	var eat = ['meat',...foods];
	console.log(foods);//["apple", "milk"]
	console.log(...foods);//apple milk
	console.log(eat);//["meat", "apple", "milk"]

箭头函数：